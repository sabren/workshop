#!/usr/bin/env python2.5
from narrative import testcase
from strongbox import *
from unittest import TestCase
from clerks import *
from storage import RamStorage
import unittest

# * intro: what are clerks?
"""
Clerks are little objects that fetch and store strongbox-style
data objects from a database or other data store. If your data
store is a relational database, then you can think of a Clerk as
an object-relational-mapper.

Clerks also work with strongboxen to let you load data on the fly.
That is, if you have a tree of objects, you can load the top one,
and the children are only loaded when you actually access them.

Note that the objects never talk to the database directly. Why? Well,
the main idea is that sometimes, especially for testing, you want
to create objects that don't live in the database. I used to use
records that were tightly bound to the database, but I found it
was easier to just use one 'Clerk' object.

"""

# * basic interface: .store and .fetch
"""
You need these things to use clerk:

  - a strongbox data class (see strongbox.py)
  - an attribute called ID on the strongbox
  - a storage object (see storage.py)
  - a clerks.Schema object (see below)

For example, here is a simple Record class:
"""

class Record(Strongbox):
    ID = attr(long)
    val = attr(str)
    next = link(lambda : Record)

"""
We'll store each Record in a table called 'records_table'
and we'll use a column called 'nextID' to hold the ID
of the 'next' link.

To make this work, we need to define a schema.
The schema is just a wrapper around a dictionary,
which maps classes to table names and link attributes
to foreign key column names.

Here is the schema for our Record object:
"""

recordSchema = Schema({
    Record: "records_table",
    Record.next: "nextID",
})


"""
We'll just use a RamStorage instance for our storage
so we don't have to worry about setting up a database.

Here's how to store and retrieve a record:
"""

@testcase
def test_basics(test):

    # create the clerk
    store = RamStorage()
    clerk = Clerk(store, recordSchema)

    # create and store a record
    r = Record(val='hello')

    # notice the ID is blank:
    assert r.ID == 0 
    assert r.next is None

    # now store it:
    clerk.store(r)

    # note that the object is updated in place:
    assert r.ID == 1
    assert r.next is None

    # here's what's in the table:
    # note the nextID is 0 because r.next is None
    db_row = store.match("records_table")
    assert db_row == [{"ID":1, "val":"hello", "nextID":0}], db_row

    # now we can retrieve it by passing the ID to fetch
    a = clerk.fetch(Record, 1)

    # we can also pass in a where clause if we KNOW we'll only
    # get one record back. (To match more than one record, use
    # match. - see below.)
    b = clerk.fetch(Record, val='hello')

    # and note that we always get the same object,
    # so if you change one, they all change.
    c = clerk.fetch(Record, 1)
    assert a is r
    assert b is r
    assert c is r


# * matching objects



# * deleting objects



# * Lazyloading with Injectors
# ** what are injectors?
"""
Imagine that you have a tree of objects 10 levels deep. For
example, a relationship mapping bosses to subordinates.
You don't want to have to load the whole tree just to retrieve
the CEO of a company.

If we'd gone the SQLObject route, then every object knows
about the database, so it's easy to for the object to just load
each level of the hierarchy directly. But our objects don't
know anything about how they're stored. So how to handle that?

What we do is we do is create a shell object. That is, an
object that holds the place of a record but not the data.

Imagine a tree that looks like this:

        office - manager - projects
                   |
        office - workers - projects


class Office:
    manager = link(lambda: Person)
    workers = linkset(lambda: Person)

class Person:
    office = link(Office)
    projects = linkset(lambda: Project)

class Project

# todo: this ought to be modelled with roles, so find
# a better example for this kind of thing.

That is, everyone in each office is assigned to
certain projects, and every office has some number
of workers and one manager. This is sort of a contrived
example, but it allows us to look at two situations:
the list of manager projects for an office and the
list of worker projects for an office.

If you imagine a database with this information, you can see
it's easy to get all the offices: select * from office.
In our scheme here, it looks like clerk.match(Office)

In the database, the Office table would have managerID
column, and there would be a separate table for
workers: ID, officeID, personID

...

I'm trying to show that we have empty objects, and you can't
tell what state they're in until they're observed.

PEAK seems to do this with bindings...
SQLObject seems to just hold on to the database connection.
clerk takes advantage of injectors.

Start with linkset. They're just like select all.

But what if it's a 1-1 relationship? some options:

  a load each one individually (explosion!)
  b do the join up front in sql
  c load and cache the whole table
  d don't load anything

Arlo takes option c or d. option b would be nice but isn't
implemented.  So I want to show that you can load a hollow manager
object and it will know it's ID, and can therefore load its projects
without ever reading the manager data from the database!!

What about the tree explosion? Well, you can just read the
whole table at once up front...



302 stopped to fold laundry ----- [0116.2006 03:02PM]

"""
# ** LinkInjector


class Foreign(Strongbox):
    ID = attr(long)
    data = attr(str)

    # there's no explicit test for this,
    # but this is here to make sure that inject
    # handles stored calculated fields properly
    def get_calc(self):
        return 2+2
    
class Local(Strongbox):
    ref = link(Foreign)


class LinkInjectorTest(TestCase):

    def test_inject(self):
        """
        basic test case.
        """
        schema = Schema({
            Foreign: "foregin",
            Local: "local",
            Local.ref: "foreignID",
        })
        clerk = RamClerk(schema)
        
        obj = Local()
        assert obj.ref is None

        clerk.store(Foreign(data="Here I come to save the day!"))

        obj.ref = Foreign(ID=1)
        obj.ref.addInjector(LinkInjector(clerk, Foreign, 1).inject)
        assert len(obj.ref.private.injectors) == 1

        # should be able to fetch the ID without triggering load
        assert obj.ref.ID == 1
        assert obj.ref.private.data == ""
        assert len(obj.ref.private.injectors) == 1

        # but getting any other field triggers the load!
        assert obj.ref.data == "Here I come to save the day!"
        assert len(obj.ref.private.injectors) == 0


    def test_with_linkset(self):
        """
        what happens if the thing we're injecting
        has a linkset of its own (this used to fail)
        """

        class Kid(Strongbox):
            ID = attr(long)
            parent = link(lambda : Parent)
        
        class Parent(Strongbox):
            ID = attr(long)
            name = attr(str)
            kids = linkset(Kid, "parent")
        
        class Uncle(Strongbox):
            brother = link(Parent)

        schema = Schema({
            Kid: "kid",
            Kid.parent: "parentID",
            Parent: "parent",
            Uncle: "uncle",
            Uncle.brother: "brotherID",
        })
        clerk = RamClerk(schema)


        kid = Kid()
        dad = Parent(name="Brother Dad")
        dad.kids << kid
        clerk.store(dad)
        
        unc = Uncle()
        unc.brother = Parent(ID=1)
        unc.brother.addInjector(LinkInjector(clerk, Parent, 1).inject)

        ## this next line threw an AttributeError because the
        ## injector tried to include "kids" in the .update() call
        assert unc.brother.name=="Brother Dad"

class LinkSetInjectorTest(TestCase):

    def test_inject(self):

        ms = MockStorage()
        ms.store("Package")
        ms.store("Content", data="I'm content", boxID=1)
        ms.store("Content", data="I'm mal content", boxID=1)

        schema = Schema({
            Content: "content",
            Content.box: "boxID",
            Package: "package",
        })

        clerk = Clerk(ms, schema)

        pak = Package()
        pak.refs << Content(data="I'm content", box=pak)
        pak.refs << Content(data="I'm malcontent", box=pak)
        pak = clerk.store(pak)

        # @TODO: should be able to add to the index without
        # triggering load (for performance reasons)
        # -- so long as any other use DOES trigger load --


        clerk.cache.clear()
        pak = clerk.fetch(Package, ID=1)
        
        # asking for .refs will trigger the load:
        assert len(pak.private.refs) == 0, pak.private.refs
        assert len(pak.refs) == 2

        # make sure it works with << on a fresh load too:
        newClerk = Clerk(clerk.storage, clerk.schema)
        pak = newClerk.fetch(Package, ID=1)
        assert len(pak.private.refs) == 0
        pak.refs << Content(data="I'm malcontent",  box=pak)
        assert len(pak.refs) == 3


class Content(Strongbox):
    ID = attr(long)
    box = link(lambda : Package)
    data = attr(str)


class Package(Strongbox):
    ID = attr(long)
    refs = linkset(Content, "box")



class Loop(Strongbox):
    next = link(lambda : Loop)
    tree = linkset((lambda : Loop), "next")
Loop.next.type = Loop
Loop.tree.type = Loop

class SchemaTest(unittest.TestCase):

    def test_schema(self):
        s = Schema({
            Loop: "loop_table",
            Loop.next: "nextID",
        })
        assert s.tableForClass(Loop) == "loop_table"
        assert s.columnForLink(Loop.next) == "nextID"

        # it should be smart enough to infer these:
        assert s.tableForLink(Loop.next) == "loop_table"
        assert s.tableForLinkSet(Loop.tree) == "loop_table"
        assert s.columnForLinkSet(Loop.tree) == "nextID"

class Node(Strongbox):
    ID = attr(long)
    data = attr(str)
    parent = link(lambda : Node)
    kids = linkset((lambda : Node), "parent")
Node.kids.type=Node
Node.parent.type=Node   

class ClerkTest(unittest.TestCase):

    def setUp(self):
        self.storage = MockStorage()
        schema = Schema({
            Node: "Node",
            Node.parent: "parentID",
            Record: "Record",
            Record.next: "nextID",
        })
        self.clerk = Clerk(self.storage, schema)


    def test_store_again(self):
        self.clerk.store(Record())
        r = self.clerk.fetch(Record, 1)
        r.val = "abc"
        self.clerk.store(r)

    def test_store_link(self):
        r = Record(val="a")
        r.next = Record(val="b")

        self.clerk.store(r)
        del r
        r = self.clerk.match(Record, val="a")[0]
        assert r.ID == 2, "didn't save links first!"
        assert r.next is not None, "didn't store the link"
        assert r.next.val=="b", "didn't store link correctly"

        r.next = None
        self.clerk.store(r)
        r = self.clerk.match(Record, val="a")[0]
        assert r.next is None, "didn't delete link!"

        r = Record(val="noNext")
        self.clerk.store(r)
        r = self.clerk.fetch(Record, val="noNext")
        assert r.next is None


    def test_store_memo(self):
        rb = self.clerk.store(Record(val="b"))
        ra = self.clerk.store(Record(val="a", next=rb))

        a,b = self.clerk.match(Record, orderBy="val")
        assert a is ra
        assert b is rb


    def test_store_linksets(self):
        n1 = Node(data="a")
        n1.kids << Node(data="aa")
        n1.kids << Node(data="ab")
        n1.kids[1].kids << Node(data="aba")
        self.clerk.store(n1)
        assert len(n1.kids)== 2, [(k.ID, k.data) for k in n1.kids]        

        n = self.clerk.fetch(Node, 1)
        assert n is n1
        assert len(n1.kids)== 2, \
               "fetch corrupted kids: %s" % [(k.ID, k.data) for k in n1.kids]
        
        assert n.ID == 1, "didn't save parent of linkset first!"
        assert len(n.kids)== 2, \
               "didn't store the linkset: %s" % [(k.ID, k.data) for k in n.kids]
        assert n.kids[0].data=="aa", "didn't store link correctly"
        assert n.kids[1].data=="ab", "didn't store link correctly"
        assert n.kids[1].kids[0].data=="aba", "didn't store link correctly"
        assert n.kids[0].parent is n
        assert n.kids[1].parent is n

        n.kids[1].parent=None
        n.kids.remove(n.kids[1])
        self.clerk.store(n)
        n = self.clerk.match(Node, data="a")[0]
        assert len(n.kids) == 1

        
        
    def test_fetch(self):
        self.clerk.store(Record(val="howdy"))

        # we can pass in an ID:
        obj = self.clerk.fetch(Record, 1)
        assert obj.val == "howdy"

        # or we can use keywords:
        obj = self.clerk.fetch(Record, val="howdy")
        assert obj.val == "howdy"


    def test_delete(self):
        self.test_fetch()
        self.clerk.delete(Record, 1)
        assert self.storage.match("Record") == []


    def test_link_injection(self):
        self.storage.store("Record", val="a", nextID=2)
        self.storage.store("Record", val="b", nextID=3)
        self.storage.store("Record", val="c", nextID=None)

        a = self.clerk.fetch(Record, 1)
        
        assert a.val == "a"
        assert a.next.val == "b"
        assert a.next.next.val == "c"
        assert a.next.next.next is None


    def test_linkset_injection(self):
        self.storage.store("Node", data="top", parentID=None)
        self.storage.store("Node", data="a",   parentID=1)
        self.storage.store("Node", data="a.a", parentID=2)
        self.storage.store("Node", data="b",   parentID=1)
        
        top = self.clerk.fetch(Node, 1)
        assert top.kids[0].data == "a"
        assert top.kids[1].data == "b"
        assert top.kids[1].kids == []
        assert top.kids[0].kids[0].data == "a.a"

        

    def test_fetch_from_wide_table(self):
        """
        Supose a strongbox has 1 slot, but the table has 2+ columns.
        We can't just jam those columns into the strongbox,
        because strongbox is *designed* to blow up if you try
        to add new attributes.

        But on the other hand, a DBA should be able to add columns
        to the databaes without breaking the code and causing
        AttributeErrors all over the place.

        Instead, Clerk should only use the columns that have
        matching attributes, and simply ignore the others.

        This sorta violates the concept of OnceAndOnlyOnce,
        because now the tables can be out of sync with the
        data model, but I think it's better than the alternative,
        and this is the sort of thing one could check with
        an automated tool.

        #@TODO: write tool to compare DB and object models :)
        """
        try:
            self.storage.store("Record", val="a", extra_column="EEK!")
            a = self.clerk.fetch(Record, 1)
            a.val="aa"
            self.clerk.store(a)
        except AttributeError:
            self.fail("shouldn't die when columns outnumber attributes")


    def test_calculated_columns(self):
        """
        Along those lines, if the table caches calculated
        fields we need to filter them out when we fetch
        """
        class Calculated(StrongBox):
            ID = attr(int)
            a = attr(int)
            def get_b(self):
                return 5
            c = attr(int)
        calc = self.clerk._rowToInstance({"ID":0, "a":1,"b":2,"c":3}, Calculated)
        assert calc.a == 1
        assert calc.b == 5
        assert calc.c == 3

        # the point is, b has to be ignored because
        # normally it raises an error:
        self.assertRaises(AttributeError, setattr, calc, "b", 2)
        

    def test_dirt(self):
        # dirty by default (already tested in strongbox)
        r = Record()
        assert r.private.isDirty

        # but not after a store:
        r = self.clerk.store(r)
        assert not r.private.isDirty

        # and not after a fetch:
        r = self.clerk.fetch(Record, ID=1)
        assert not r.private.isDirty

        # or a match:
        r = self.clerk.match(Record)[0]
        assert not r.private.isDirty


    def test_recursion(self):
        r = Record()
        r.next = Record()
        r.next.next = r
        assert r.private.isDirty
        assert r.next.private.isDirty
        r = self.clerk.store(r)
        assert r.ID == 2
        assert r.next.ID == 1

        r = self.clerk.fetch(Record, 2)
        assert not r.private.isDirty
        assert not r.next.private.isDirty


        ## and the same thing for linksets:
        n = Node()
        n.kids << Node()
        n.kids[0].kids << n
        assert n.private.isDirty
        assert n.kids[0].private.isDirty
        n = self.clerk.store(n)
        
        
    def test_identity(self):
        self.clerk.store(Record(val="one"))
        rec1a = self.clerk.fetch(Record, 1)
        rec1b = self.clerk.fetch(Record, 1)
        assert rec1a is rec1b

        n = Record()
        r = Record(next=n)        
        assert self.clerk.store(r) is r
        assert self.clerk.cache[(Record, r.ID)] is r
        assert self.clerk.cache[(Record, n.ID)] is n
        assert self.clerk.cache[(Record, n.ID)] is r.next

    def test_stub(self):
        self.clerk.store(Record(val="a", next=Record(val="b")))
        self.clerk.cache.clear()
        recA = self.clerk.fetch(Record, val="a")
        recB = self.clerk.fetch(Record, val="b")
        assert recA.next.ID == recB.ID
        assert recA.next is recB

    def test_match(self):
        self.clerk.store(Record(val="one"))
        self.clerk.store(Record(val="two"))
        self.clerk.store(Record(val="two"))
        assert len(self.clerk.match(Record, val="zero")) == 0
        assert len(self.clerk.match(Record, val="one")) == 1
        assert len(self.clerk.match(Record, val="two")) == 2
        
    def test_matchOne(self):
        self.clerk.store(Record(val="one"))
        self.clerk.store(Record(val="two"))
        self.clerk.store(Record(val="two"))
        
        try:
            self.clerk.matchOne(Record, val="zero")
            self.fail("should have failed for not matching")
        except LookupError: pass

        assert isinstance(self.clerk.matchOne(Record, val="one"),
                          Record)

        try:
            self.clerk.matchOne(Record, val="two")
            self.fail("should have failed for matching two")
        except LookupError: pass


class Thing(Strongbox):
    ID = attr(long)
    x = attr(str)

class OtherThing(Strongbox):
    ID = attr(long)
    x = attr(str)

class CallbackClerkTest(unittest.TestCase):

    def test_onStore(self):
        queue = []
        schema = Schema({
            Thing: "thing",
            OtherThing: "other",
        })
            
        clerk = CallbackClerk(MockStorage(), schema)
        clerk.onStore(Thing, queue.append)
        
        clerk.store(Thing(x="a"))
        clerk.store(Thing(x="b"))
        clerk.store(OtherThing(x="not me"))


        queue2 = []
        clerk.onStore(Thing, queue2.append)
        clerk.store(Thing(x="c"))

        # "c" should wind up in both:
        assert len(queue) == 3
        assert "".join([t.x for t in queue]) == "abc"

        assert len(queue2) == 1
        assert queue2[0].x=="c"



class RegressionTest(unittest.TestCase):

    def test_disappearing_events(self):
        """
        This bug came from duckbill. A subscription
        would post events to its account, and then
        when it showed the statements the new events
        would be the only ones to show up - even though
        there were still others in the database.

        In other words, the injector wasn't working.

        Turns out the problem was that the sub.account
        stub didn't have injectors on ITS dependent
        objects. That's why I now replace .private
        in LinkInjector.inject()
        """
        class Evt(Strongbox):
            ID = attr(long)
            evt = attr(str)
            acc = link(lambda : Acc)
        class Sub(Strongbox):
            ID = attr(long)
            acc = link(lambda : Acc)
        class Acc(Strongbox):
            ID = attr(long)
            subs = linkset(Sub, "acc")
            evts = linkset(Evt, "acc")
        schema = Schema({
            Evt:"evt",
            Sub:"sub",
            Acc:"acc",
            Evt.acc: "accID",
            Sub.acc: "accID",
        })
        st = MockStorage()
        c1 = Clerk(st, schema)

        # store an account with two events and one sub:
        a = Acc()
        a.evts << Evt(evt="1")
        a.evts << Evt(evt="2")
        assert a.private.isDirty
        a.subs << Sub()
        c1.DEBUG = 1
        c1.store(a)

        # new clerk, new cache:
        c2 = Clerk(st, schema)

        # add more events while s.acc is a stub
        s = c2.fetch(Sub, ID=1)
        assert s.private.isDirty==False
        #@TODO: maybe len() should trigger the lazyload...
        assert len(s.acc.evts) == 0, [e.evt for e in s.acc.evts]
        s.acc.evts << Evt(evt="3")
        #assert len(s.acc.evts) == 1, [e.evt for e in s.acc.evts]
        assert len(s.acc.evts) == 3, [e.evt for e in s.acc.evts]
        c2.DEBUG = 0
        c2.store(s)
        a2 = c2.fetch(Acc, ID=a.ID)

        assert a is not a2

        # we should now have all three events,
        # but we were getting only the third one:
        assert len(a2.evts) == 3, [e.evt for e in a2.evts]
    

    def test_complex_recursion(self):
        """
        test case from cornerhost that exposed a bug.
        this is probably redundant given test_recursion
        but it doesn't hurt to keep it around. :)

        This test is complicated. Basically it sets up
        several classes that refer to each other in a loop
        and makes sure it's possible to save them without
        infinite recursion.
        
        @TODO: isInstance(LinkSetInjector) in Clerk.py need tests
        It ought to do some kind of polymorphism magic anyway.
        (huh??)
        """

        class User(Strongbox):
            ID = attr(long)
            username = attr(str)
            domains = linkset((lambda : Domain),"user")
            sites = linkset((lambda : Site),"user")
        class Domain(Strongbox):
            ID = attr(long)
            user = link(User)
            name = attr(str)
            site = link(lambda : Site)            
        class Site(Strongbox):
            ID = attr(long)
            user = link(User)
            domain = link(Domain)
        dbMap = Schema({
            User:"user",
            Domain:"domain",
            Domain.user: "userID",
            Domain.site: "siteID",
            Site:"site",
            Site.user: "userID",
            Site.domain: "domainID",
        })
       
        clerk = Clerk(MockStorage(), dbMap)
        u = clerk.store(User(username="ftempy"))
        u = clerk.match(User,username="ftempy")[0]
        d = clerk.store(Domain(name="ftempy.com", user=u))
        assert d.user, "didn't follow link before fetch"
        d = clerk.match(Domain, name="ftempy.com")[0]

        # the bug was here: it only happened if User had .domains
        # I think because it was a linkset, and the linkset had
        # an injector. Fixed by inlining the injector test into
        # Clekr.store:
        assert d.user, "didn't follow link after fetch"
        assert d.user.ID == u.ID

        # ah, but then we had an infinite recursion problem
        # with site, but I fixed that with private.isDirty:
        d.site = clerk.store(Site(domain=d))
        d = clerk.store(d)
        assert d.site.domain.name == "ftempy.com"

        # and again here:
        d = clerk.fetch(Domain, 1)
        assert not d.private.isDirty
        assert not d.site.private.isDirty # this failed.
        clerk.store(d)                    # so this would recurse forever





if __name__=="__main__":
    unittest.main()

